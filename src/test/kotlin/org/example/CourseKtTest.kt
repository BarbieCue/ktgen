package org.example

import io.kotest.assertions.throwables.shouldNotThrow
import io.kotest.inspectors.forAll
import io.kotest.matchers.collections.shouldHaveAtLeastSize
import io.kotest.matchers.collections.shouldHaveSize
import io.kotest.matchers.ints.shouldBeGreaterThanOrEqual
import io.kotest.matchers.shouldBe
import io.kotest.matchers.shouldNotBe
import io.kotest.matchers.string.shouldContain
import io.kotest.matchers.string.shouldHaveMaxLength
import io.kotest.matchers.string.shouldHaveMinLength
import java.io.ByteArrayOutputStream
import java.io.File
import java.io.PrintStream
import java.nio.file.attribute.PosixFilePermissions
import java.util.*
import kotlin.io.path.absolutePathString
import kotlin.io.path.createTempDirectory
import kotlin.io.path.exists

class CourseKtTest : IOExpectSpec({

    context("writeCourseFile") {

        expect("file exists after successful write") {
            val file = tmpFile("my_test_course${UUID.randomUUID()}.xml")
            writeCourseFile(file.absolutePathString(), Course())
            file.exists() shouldBe true
        }

        expect("file does not exist when writing failed") {
            val readOnly = PosixFilePermissions.fromString("r--r--r--")
            val fileAttributes = PosixFilePermissions.asFileAttribute(readOnly)
            val roDir = createTempDirectory("my-ro-dir", fileAttributes)
            val path = "$roDir/my_test_course${UUID.randomUUID()}.xml"
            writeCourseFile(path, Course())
            File(path).exists() shouldBe false
        }

        expect("nothing happens when path is empty") {
            shouldNotThrow<Exception> { writeCourseFile("", Course()) }
        }

        expect("nothing happens when path is invalid") {
            shouldNotThrow<Exception> { writeCourseFile("{/}....{}*", Course()) }
        }
    }

    context("writeCourse") {

        expect("file exists after successful write") {
            val dir = createTempDirectory("my-dir")
            val path = "$dir/my_test_course${UUID.randomUUID()}.xml"
            writeCourse(Course(), listOf(path))
            File(path).exists() shouldBe true
        }

        expect("file does not exist when writing failed") {
            val readOnly = PosixFilePermissions.fromString("r--r--r--")
            val fileAttributes = PosixFilePermissions.asFileAttribute(readOnly)
            val roDir = createTempDirectory("my-ro-dir", fileAttributes)
            val path = "$roDir/my_test_course${UUID.randomUUID()}.xml"
            writeCourse(Course(), listOf(path))
            File(path).exists() shouldBe false
        }

        expect("nothing happens when path is empty") {
            shouldNotThrow<Exception> { writeCourse(Course(), listOf("")) }
        }

        expect("nothing happens when path is invalid") {
            shouldNotThrow<Exception> { writeCourse(Course(), listOf("{/}....{}*")) }
        }

        context("stdio") {

            val outStreamCaptor = ByteArrayOutputStream()
            beforeEach {
                outStreamCaptor.reset()
                System.setOut(PrintStream(outStreamCaptor))
            }

            afterEach {
                System.setOut(System.out)
            }

            expect("write course to stdout when 'stdout' is a target") {
                val course = createCourse(emptyList(), emptySequence(), 0, 0)
                writeCourse(course, listOf("stdout"))
                outStreamCaptor.toString().trim() shouldContain course.id
            }
        }
    }

    context("createCourse") {

        expect("have meta information set") {
            val course = createCourse(emptyList(), emptySequence(), 0, 0)
            course.keyboardLayout shouldBe ""
            shouldNotThrow<Exception> { UUID.fromString(course.id) }
            course.title shouldBe "Generated by ktgen"
            course.description shouldBe "Visit ktgen on Github (https://github.com/BarbieCue/ktgen)"
        }

        expect("course consists of lessons containing the specified symbols") {
            val lessonSpecification = listOf("ab", "cd")
            val course = createCourse(lessonSpecification, emptySequence(), 20, 100)
            course.lessons.joinToString("") { it.newCharacters } shouldBe "abcd"
        }

        expect("course has no lessons when there are no specified symbols") {
            val lessonSpecification = emptyList<String>()
            val course = createCourse(lessonSpecification, emptySequence(), 20, 100)
            course.lessons shouldBe emptyList()
        }

        expect("each lesson text contains exactly the specified amount of non-whitespace symbols (symbols-per-lesson)") {
            val lessonSpecification = listOf("ab", "cd")
            val symbolsPerLesson = 100
            val course = createCourse(lessonSpecification, emptySequence(), 20, symbolsPerLesson)
            course.lessons shouldHaveAtLeastSize 2
            course.lessons.forAll { it.text.count { char -> !char.isWhitespace() } shouldBe 100 }
        }

        expect("each line of each lesson's text has a length of about line-length, except the last line can be shorter") {
            val lessonSpecification = listOf("ab", "cd")
            val lineLength = 20
            val course = createCourse(lessonSpecification, emptySequence(), lineLength, 100)
            course.lessons shouldHaveAtLeastSize 2
            repeat(100) {
                course.lessons.forAll { lesson ->
                    val lines = lesson.text.split('\n')
                    lines shouldHaveAtLeastSize 2
                    lines.dropLast(1).forAll { line ->
                        line shouldHaveMinLength 10
                        line shouldHaveMaxLength 30
                    }
                }
            }
        }

        expect("course contains word lessons when a non-empty dictionary with matching words is passed") {
            val lessonSpecification = listOf("ab", "cd", "ef", "gh", "ij", "kl")
            val dictionary = sequenceOf("kkkk", "llll", "kl", "ll", "kk", "flache", "all", "gleich", "gleiche", "bald", "alle", "a", "flach")
            repeat(100) {
                val course = createCourse(lessonSpecification, dictionary, 20, 100)
                course.lessons shouldHaveAtLeastSize 1
                course.lessons.count { it.text.contains("all") } shouldBeGreaterThanOrEqual 1
            }
        }

        expect("line-length range test") {
            val lessonSpecification = listOf("ab")
            createCourse(lessonSpecification, emptySequence(), -100, 200).lessons shouldHaveSize 0
            createCourse(lessonSpecification, emptySequence(), -1, 200).lessons shouldHaveSize 0
            createCourse(lessonSpecification, emptySequence(), 0, 200).lessons shouldHaveSize 0
            createCourse(lessonSpecification, emptySequence(), 1, 200).lessons.size shouldBeGreaterThanOrEqual 1
            repeat(100) {
                createCourse(lessonSpecification, emptySequence(), 1, 200).lessons.forAll {
                    it.text.split('\n') shouldNotBe emptyList<String>()
                    it.text.split('\n').forAll { line -> line shouldHaveMinLength 1 }
                }
                createCourse(lessonSpecification, emptySequence(), 100, 200).lessons.size shouldBeGreaterThanOrEqual 1
                createCourse(lessonSpecification, emptySequence(), 100, 200).lessons.forAll {
                    it.text.split('\n') shouldNotBe emptyList<String>()
                    it.text.split('\n').dropLast(1).forAll { line ->
                        line shouldHaveMinLength 90
                        line shouldHaveMaxLength 110
                    }
                }
            }
        }

        expect("symbols-per-lesson range test") {
            val lessonSpecification = listOf("ab")
            createCourse(lessonSpecification, emptySequence(), 100, -100).lessons shouldHaveSize 0
            createCourse(lessonSpecification, emptySequence(), 100, -1).lessons shouldHaveSize 0
            createCourse(lessonSpecification, emptySequence(), 100, 0).lessons shouldHaveSize 0
            createCourse(lessonSpecification, emptySequence(), 100, 1).lessons.size shouldBeGreaterThanOrEqual 1
            createCourse(lessonSpecification, emptySequence(), 100, 1).lessons.forAll { it.text.count { char -> !char.isWhitespace() } shouldBe  1 }
            createCourse(lessonSpecification, emptySequence(), 100, 100).lessons.size shouldBeGreaterThanOrEqual 1
            createCourse(lessonSpecification, emptySequence(), 100, 100).lessons.forAll { it.text.count { char -> !char.isWhitespace() } shouldBe  100 }
        }
    }
})