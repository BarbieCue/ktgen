package org.example

import io.kotest.assertions.throwables.shouldNotThrow
import io.kotest.inspectors.forAll
import io.kotest.matchers.collections.shouldHaveSize
import io.kotest.matchers.shouldBe
import io.kotest.matchers.string.shouldHaveLength
import io.kotest.matchers.string.shouldHaveMaxLength
import io.kotest.matchers.string.shouldHaveMinLength
import org.junit.jupiter.api.AfterAll
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.TestInstance
import java.io.File
import java.nio.file.Files
import java.nio.file.attribute.PosixFilePermissions
import java.util.*
import kotlin.io.path.Path

@TestInstance(TestInstance.Lifecycle.PER_CLASS)
class CourseKtTest {

    private val files = mutableListOf<String>()

    @AfterAll
    fun deleteFiles() {
        files.forEach { File(it).delete() }
    }

    @Test
    fun `readCourseSymbols happy`() {
        val filename = "ktgen_course_definition_test${UUID.randomUUID()}"
        files.add(filename)
        File(filename).writeText("apple\npear\ngrape")
        readCourseSymbols(filename) shouldBe listOf("apple", "pear", "grape")
    }

    @Test
    fun `readCourseSymbols file not exists`() {
        readCourseSymbols("a_non_existing_file") shouldBe emptyList()
    }

    @Test
    fun `readCourseSymbols empty path`() {
        readCourseSymbols("") shouldBe emptyList()
    }

    @Test
    fun `readCourseSymbols file empty`() {
        val filename = "ktgen_course_definition_test${UUID.randomUUID()}"
        files.add(filename)
        File(filename).writeText("")
        readCourseSymbols(filename) shouldBe emptyList()
    }

    @Test
    fun `writeCourseFile empty path`() {
        writeCourseFile("", Course(lessons = emptyList())) shouldBe false
    }

    @Test
    fun `writeCourseFile relative path`() {
        val filename = "my_test_course${UUID.randomUUID()}.xml"
        files.add(filename)
        writeCourseFile(filename, Course(lessons = emptyList())) shouldBe true
        File(filename).exists() shouldBe true
    }

    @Test
    fun `writeCourseFile cannot write file`() {
        val readOnlyDir = "dir${UUID.randomUUID()}"
        val filename = "my_test_course${UUID.randomUUID()}.xml"
        files.add("$readOnlyDir/$filename")
        files.add(readOnlyDir)

        File(readOnlyDir).mkdir()
        val readOnly = PosixFilePermissions.fromString("r--r--r--")
        Files.setPosixFilePermissions(Path(readOnlyDir), readOnly)

        writeCourseFile("$readOnlyDir/$filename", Course(lessons = emptyList())) shouldBe false
        File("$readOnlyDir/$filename").exists() shouldBe false
    }

    @Test
    fun `Course toXml happy`() {
        Course(id = "196dc484-8148-4c6d-9700-e34d06f06a40",
            lessons = listOf(Lesson(
                id = "342e8f50-d967-4f92-ab37-ea6ecd6c58cd",
                title = "abc",
                newCharacters = "cg",
                text = "..."))).toXml() shouldBe """
            <?xml version="1.0" encoding="UTF-8"?><course>
              <id>196dc484-8148-4c6d-9700-e34d06f06a40</id>
              <title>Generated by ktgen</title>
              <description>Visit ktgen on Github (https://github.com/BarbieCue/ktgen)</description>
              <keyboardLayout/>
              <lessons>
                <lesson>
                  <id>342e8f50-d967-4f92-ab37-ea6ecd6c58cd</id>
                  <title>abc</title>
                  <newCharacters>cg</newCharacters>
                  <text>...</text>
                </lesson>
              </lessons>
            </course>
        """.trimIndent()
    }

    @Test
    fun `createCourse meta data`() {
        val course = createCourse(emptyList(), emptyList(), 0, 0)
        course.keyboardLayout shouldBe ""
        shouldNotThrow<Exception> { UUID.fromString(course.id) }
        course.title shouldBe "Generated by ktgen"
        course.description shouldBe "Visit ktgen on Github (https://github.com/BarbieCue/ktgen)"
    }

    @Test
    fun `createCourse happy`() {
        val courseSymbols = listOf("ab", "cd")
        val dictionary = listOf("apple", "pear", "grape", "cd", "in", "nice", "ai", "ab")
        val lineLength = 20
        val wordsPerLesson = 10

        val course = createCourse(courseSymbols, dictionary, lineLength, wordsPerLesson)

        // 1. lesson: random ab's
        // 2. lesson: words consisting of 'a' and 'b'
        // 3. lesson: random cd's
        // 4. lesson: words consisting of 'c' and 'd'
        course.lessons shouldHaveSize 4

        course.lessons[0].newCharacters shouldBe "ab" // introducing ab
        course.lessons[1].newCharacters shouldBe ""
        course.lessons[2].newCharacters shouldBe "cd" // introducing cd
        course.lessons[3].newCharacters shouldBe ""

        // line length check
        course.lessons[0].text.split('\n').forAll { it shouldHaveMaxLength 20 }
        course.lessons[1].text.split('\n').forAll { it shouldHaveMaxLength 20 }
        course.lessons[2].text.split('\n').forAll { it shouldHaveMaxLength 20 }
        course.lessons[3].text.split('\n').forAll { it shouldHaveMaxLength 20 }

        // number of words per lessons check
        course.lessons[1].text.split("\\s".toRegex()) shouldHaveSize 10
        course.lessons[3].text.split("\\s".toRegex()) shouldHaveSize 10

        // words content check
        course.lessons[1].text.split("\\s".toRegex()).forAll { it.consistsOfAny("ab") }
        course.lessons[3].text.split("\\s".toRegex()).forAll { it.consistsOfAny("abcd") }
    }

    @Test
    fun `createCourse empty course symbols`() {
        val courseSymbols = emptyList<String>()
        val dictionary = listOf("apple", "pear", "grape", "cd", "in", "nice", "ai", "ab")
        val lineLength = 20
        val wordsPerLesson = 10

        val course = createCourse(courseSymbols, dictionary, lineLength, wordsPerLesson)
        course.lessons shouldBe emptyList()
    }

    @Test
    fun `createCourse empty dictionary`() {
        val courseSymbols = listOf("ab", "cd")
        val dictionary = emptyList<String>()
        val lineLength = 20
        val wordsPerLesson = 10

        val course = createCourse(courseSymbols, dictionary, lineLength, wordsPerLesson)

        // 1. lesson: random ab's
        // 2. lesson: random cd's
        course.lessons shouldHaveSize 2

        course.lessons[0].newCharacters shouldBe "ab" // introducing ab
        course.lessons[1].newCharacters shouldBe "cd" // introducing cd

        // line length check
        course.lessons[0].text.split('\n').forAll { line ->
            line shouldHaveMinLength 19
            line shouldHaveMaxLength 20 }
        course.lessons[1].text.split('\n').forAll { line ->
            line shouldHaveMinLength 19
            line shouldHaveMaxLength 20 }
    }

    @Test
    fun `createCourse line length range test`() {
        val courseSymbols = listOf("ab", "cd")
        val dictionary = listOf("apple", "pear", "grape", "cd", "in", "nice", "ai", "ab")
        val wordsPerLesson = 10

        createCourse(courseSymbols, dictionary, -100, wordsPerLesson).lessons.forAll { it.text.split('\n').forAll { line -> line shouldHaveLength 0 } }
        createCourse(courseSymbols, dictionary, -1, wordsPerLesson).lessons.forAll { it.text.split('\n').forAll { line -> line shouldHaveLength 0 } }
        createCourse(courseSymbols, dictionary, 0, wordsPerLesson).lessons.forAll { it.text.split('\n').forAll { line -> line shouldHaveLength 0 } }
        createCourse(courseSymbols, dictionary, 1, wordsPerLesson).lessons.forAll { it.text.split('\n').forAll { line ->
            line shouldHaveMinLength 0
            line shouldHaveMaxLength 1 } }
        createCourse(courseSymbols, dictionary, 100, wordsPerLesson).lessons.forAll { it.text.split('\n')
            .dropLast(1) // last line can be shorter
            .forAll { line ->
                line shouldHaveMinLength 99
                line shouldHaveMaxLength 100 } }
    }

    @Test
    fun `createCourse words per lesson range test`() {
        val courseSymbols = listOf("ab")
        val dictionary = listOf("apple", "pear", "grape", "cd", "in", "nice", "ai", "ab")
        val lineLength = 20

        // 1. lesson: random ab's
        // 2. lesson: words consisting of 'a' and 'b'
        createCourse(courseSymbols, dictionary, lineLength, -100).lessons[1].text shouldHaveLength 0
        createCourse(courseSymbols, dictionary, lineLength, -1).lessons[1].text shouldHaveLength 0
        createCourse(courseSymbols, dictionary, lineLength, 0).lessons[1].text shouldHaveLength 0
        createCourse(courseSymbols, dictionary, lineLength, 1).lessons[1].text.split("\\s".toRegex()) shouldHaveSize 1
        createCourse(courseSymbols, dictionary, lineLength, 100).lessons[1].text.split("\\s".toRegex()) shouldHaveSize 100
    }
}